https://mirror.xyz/xyyme.eth/GNVcUgKAOEiLyClKeqkmD35ctLu6_XomT3ZDIfV3tz8

### 执行 Bytecode（字节码）的机器。

EVM核心是stack machine(栈机器)，会接受操作符(Opcodes)和操作数。操作符都是一个字节，操作数可能有多个字节。



## 字节码构造

三部分：

1. init bytecode(初始化字节码)
2. runtime bytecode(运行时字节码)
3. metadata hash(合约的一些meta信息哈希)

三部分通过无效操作符（INVALID）fe分割。



metadata hash，它默认是合约 metadata 文件的 IPFS 哈希值。



## 合约内存

Memory 的数据结构就是一个简单的字节数组，数据可以以 1 字节（8 位）或者 32 字节（256 位）为单位进行存储，读取时只能以 32 字节为单位读取，但是读取时可以从任意字节处开始读取，不限定于 32 的倍数字节。

用于操作内存的一共有 3 个操作符：

- MSTORE (x, y) - 在内存 x 处开始存储 32 字节的数据 y
- MLOAD (x) - 将内存 x 处开始的 32 字节数据加载到栈中
- MSTORE8 (x, y) - 在内存 x 处存储 1 字节数据 y（32字节栈值中的最低有效字节）

Solidity 中预留了 4 个 32 字节的插槽（slot），分别是：

- `0x00` - `0x3f` (64 字节): 哈希方法的暂存空间
- `0x40` - `0x5f` (32 字节): 当前已分配内存大小 (也称为空闲内存指针)
- `0x60` - `0x7f` (32 字节): 零槽，用作动态内存数组的初始值，永远不能写入值

这里面最重要的就是中间这一项，也就是空闲指针。它会指向空闲空间的开始位置，也就是说，要将一个新变量写入内存，给它分配的位置就是空闲指针所指向的位置。需要注意的是，Solidity 中的内存是不会被释放（free）的。

对于空闲指针，它的更新遵守了很简单的原则：

> 新的空闲指针位置 = 旧的空闲指针位置 + 分配的数据大小